\documentclass{beamer}
\usepackage[utf8]{inputenc}

\usetheme{Madrid}
\usecolortheme{default}
\usepackage{extarrows}
\usepackage{amsmath}
\usepackage{extarrows}
\usepackage{amssymb,amsfonts,amsthm}
\usepackage{txfonts}
\usepackage{tkz-euclide}
\usepackage{listings}
\usepackage{adjustbox}
\usepackage{array}
\usepackage{tabularx}
\usepackage{gvv}
\usepackage{lmodern}
\usepackage{circuitikz}
\usepackage{tikz}
\usepackage{graphicx}
\usepackage{amsmath} 

\setbeamertemplate{page number in head/foot}[totalframenumber]

\usepackage{tcolorbox}
\tcbuselibrary{minted,breakable,xparse,skins}

\definecolor{bg}{gray}{0.95}
\DeclareTCBListing{mintedbox}{O{}m!O{}}{%
  breakable=true,
  listing engine=minted,
  listing only,
  minted language=#2,
  minted style=default,
  minted options={%
    linenos,
    gobble=0,
    breaklines=true,
    breakafter=,,
    fontsize=\small,
    numbersep=8pt,
    #1},
  boxsep=0pt,
  left skip=0pt,
  right skip=0pt,
  left=25pt,
  right=0pt,
  top=3pt,
  bottom=3pt,
  arc=5pt,
  leftrule=0pt,
  rightrule=0pt,
  bottomrule=2pt,
  toprule=2pt,
  colback=bg,
  colframe=orange!70,
  enhanced,
  overlay={%
    \begin{tcbclipinterior}
    \fill[orange!20!white] (frame.south west) rectangle ([xshift=20pt]frame.north west);
    \end{tcbclipinterior}},
  #3,
}
\lstset{
    language=C,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    stringstyle=\color{orange},
    commentstyle=\color{green!60!black},
    numbers=left,
    numberstyle=\tiny\color{gray},
    breaklines=true,
    showstringspaces=false,
}
\title %optional
{12.270}
\author 
{EE25BTECH11049-Sai Krishna Bakki}

\begin{document}

\frame{\titlepage}
\begin{frame}{Question}
If
\begin{align*}
    \vec{A}=\myvec{2&4\\1&3},\vec{B}=\myvec{4&6\\5&9},
\end{align*}
$\brak{\vec{A}\vec{B}}^T$ is equal to
\end{frame}
\begin{frame}{Theoretical Solution}
    Given
\begin{align}
    \vec{A}=\myvec{2&4\\1&3},\vec{B}=\myvec{4&6\\5&9},
    \vec{A}^T=\myvec{2&1\\4&3},\vec{B}^T=\myvec{4&5\\6&9}
\end{align}
$\brak{\vec{A}\vec{B}}^T$ can also be written as $\vec{B}^T\vec{A}^T$
\begin{align}
    \brak{\vec{A}\vec{B}}^T=\vec{B}^T\vec{A}^T\\
    \implies \myvec{4&5\\6&9}\myvec{2&1\\4&3}\\
    \implies\myvec{8+20&4+15\\12+36&6+27}\\
    \implies \myvec{28&19\\48&33}
\end{align}
$\therefore$ $ \brak{\vec{A}\vec{B}}^T$ is equal to  $\myvec{28&19\\48&33}$.
\end{frame}
\begin{frame}[fragile]
\frametitle{C Code}
\begin{lstlisting}
#include <stdio.h>

// This function multiplies two 2x2 matrices (A and B) and stores the
// transpose of the result in the `result` matrix.
// Matrices are passed as pointers to 1D arrays of size 4 (row-major order).
void multiply_and_transpose(double* A, double* B, double* result) {
    double product[4];

    // Perform matrix multiplication: C = A * B
    // C[0,0] = A[0,0]*B[0,0] + A[0,1]*B[1,0]
    product[0] = A[0] * B[0] + A[1] * B[2];
    // C[0,1] = A[0,0]*B[0,1] + A[0,1]*B[1,1]
    product[1] = A[0] * B[1] + A[1] * B[3];
    // C[1,0] = A[1,0]*B[0,0] + A[1,1]*B[1,0]
\end{lstlisting}
\end{frame}
\begin{frame}[fragile]
\frametitle{C Code}
\begin{lstlisting}
    product[2] = A[2] * B[0] + A[3] * B[2];
    // C[1,1] = A[1,0]*B[0,1] + A[1,1]*B[1,1]
    product[3] = A[2] * B[1] + A[3] * B[3];

    // Transpose the product matrix and store it in the result
    // result[0,0] = product[0,0]
    result[0] = product[0];
    // result[0,1] = product[1,0]
    result[1] = product[2];
    // result[1,0] = product[0,1]
    result[2] = product[1];
    // result[1,1] = product[1,1]
    result[3] = product[3];
}
\end{lstlisting}
\end{frame}
\begin{frame}[fragile]
\frametitle{Python Code Through Shared Output}
\begin{lstlisting}
import ctypes
import numpy as np
import os

# Define the name of the shared library based on the operating system
if os.name == 'nt':  # Windows
    lib_name = 'matrix_ops.dll'
else:  # Linux, macOS, etc.
    lib_name = 'matrix.so'
    
# Check if the library file exists before trying to load it
if not os.path.exists(lib_name):
    print(f"Error: Shared library '{lib_name}' not found.")
    print("Please compile 'matrix_ops.c' first. See README.md for instructions.")
    exit()
\end{lstlisting}
\end{frame}
\begin{frame}[fragile]
\frametitle{Python Code Through Shared Output}
\begin{lstlisting}
# Load the shared library
c_lib = ctypes.CDLL(os.path.abspath(lib_name))

# Define the argument types and return type for the C function.
# This ensures Python sends the data in the correct format.
# The function expects three arguments: pointers to C doubles.
c_lib.multiply_and_transpose.argtypes = [
    ctypes.POINTER(ctypes.c_double), 
    ctypes.POINTER(ctypes.c_double), 
    ctypes.POINTER(ctypes.c_double)
]
# The C function doesn't return a value; it modifies the 'result' array in place.
c_lib.multiply_and_transpose.restype = None

# Define the input matrices using numpy.
# It's crucial to specify the dtype as np.double to match 'c_double' in ctypes.
A = np.array([[2, 4], [1, 3]], dtype=np.double)
B = np.array([[4, 6], [5, 9]], dtype=np.double)

# Create an empty numpy array to store the result from the C function.
result_from_c = np.empty((2, 2), dtype=np.double)
\end{lstlisting}
\end{frame}
\begin{frame}[fragile]
\frametitle{Python Code Through Shared Output}
\begin{lstlisting}
# Convert the numpy arrays into a format that ctypes can use.
# This gets a C-compatible pointer to the underlying data buffer of the array.
A_ptr = A.ctypes.data_as(ctypes.POINTER(ctypes.c_double))
B_ptr = B.ctypes.data_as(ctypes.POINTER(ctypes.c_double))
result_ptr = result_from_c.ctypes.data_as(ctypes.POINTER(ctypes.c_double))

# Call the C function with the pointers to the data
c_lib.multiply_and_transpose(A_ptr, B_ptr, result_ptr)

# Print the original matrices and the final result
print("Matrix A:\n", A)
print("\nMatrix B:\n", B)
print("\nResult from C function (AB)T:\n", result_from_c)
\end{lstlisting}
\end{frame}
\begin{frame}[fragile]
\frametitle{Python Code}
\begin{lstlisting}
import numpy as np
# Define the matrices A and B from the problem
A = np.array([[2, 4], 
              [1, 3]])

B = np.array([[4, 6], 
              [5, 9]])
# Step 1: Calculate the product of A and B (A multiplied by B)
# The '@' operator is used for matrix multiplication in numpy
product_AB = A @ B
# Step 2: Calculate the transpose of the resulting matrix
# The .T attribute returns the transpose of a numpy array
transpose_of_product = product_AB.T
# Print the original matrices and the final result for clarity
print("Matrix A:\n", A)
print("\nMatrix B:\n", B)
#print("\nProduct of A and B (AB):\n", product_AB)
print("\nTranspose of the product (AB)T:\n", transpose_of_product)

\end{lstlisting}
\end{frame}
\end{document}